\documentclass[french]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{fourier}

\title{Git}

\begin{document}
\date{}

\maketitle

\setlength{\parindent}{0cm}

\section{Basics}

Initilize repository:
\begin{verbatim}
  git init
\end{verbatim}

View status:
\begin{verbatim}
  git status
\end{verbatim}

Add to snapshot:
\begin{verbatim}
  git add <file>
\end{verbatim}

Commit snapshot:
\begin{verbatim}
  git commit
\end{verbatim}

View a repository's commit history:
\begin{verbatim}
  git log
  git log -n <number-of-commits>
\end{verbatim}

Show commits in branch-name2 that aren't in branch-name:
\begin{verbatim}
  git log <branch-name>..<branch-name2>
\end{verbatim}

Define author name and email:
\begin{verbatim}
  git config user.name
  git config user.email
\end{verbatim}

\section{Revert changes}

View previous commit (moves the HEAD):
\begin{verbatim}
  git checkout <commit-id>
\end{verbatim}
Rq. The HEAD is Git's internal way of indicating the snapshot that is currently checked out. The HEAD normally resides on the tip of a development branch. When we checkout a previous commit we can no longer say we are on the <branch-name> branch since it contains more recent snapshots than the HEAD $\rightarrow$ currently on no branch.\\

Go back to last commit:
\begin{verbatim}
  git checkout master
\end{verbatim}

Tag a commit (for easier acces):
\begin{verbatim}
  git tag -a <tag-name> -m <description>
\end{verbatim}

Revert a commit (commits a new snapshot without the specified one):
\begin{verbatim}
  git revert <commit-id>
\end{verbatim}

Unstage files:
\begin{verbatim}
  git reset
\end{verbatim}

Undo uncommitted changes (\danger\ operate on the working directory, not on committed snapshots. Permanently undo changes):
\begin{itemize}
\item [-] Change all tracked files to match the most recent commit:
\begin{verbatim}
  git reset --hard
\end{verbatim}
\item [-] Remove all untracked files:
\begin{verbatim}
  git clean -f
\end{verbatim}
\end{itemize}

\section{Branches}

Rq. It's not possible to add new commits when not on a branch.\\

List existing branches:
\begin{verbatim}
  git branch
\end{verbatim}

Create new branch:
\begin{verbatim}
  git branch <branch-name>
\end{verbatim}

Checkout branch:
\begin{verbatim}
  git checkout <branch-name>
\end{verbatim}

Create and checkout branch:
\begin{verbatim}
  git checkout -b <branch-name>
\end{verbatim}

Remove file from working directory and index:
\begin{verbatim}
  git rm <file-name>
\end{verbatim}

Merge branch to current one:
\begin{verbatim}
  git merge <branch-name>
\end{verbatim}

Rq. Merge types
\begin{itemize}
  \item [-] Fast-forward merge: There's no commits since merged branch was created. Git simply moves the tip of the branch and doesn't need a merge commit.
  \item [-] 3-way merge: Two branches whose history has diverged. It creates an extra commit.
\end{itemize}$ $\\

Delete branch
\begin{verbatim}
  git branch -d <branch-name>
\end{verbatim}

\section{Rebasing}

Rebase branch to current branch:
\begin{verbatim}
  git rebase <new-base>
\end{verbatim}

Interactive rebase (Rebase and modify commits):
\begin{verbatim}
  git rebase -i <new-base>
\end{verbatim}

Rq. Interactive rebase commands:
\begin{itemize}
  \item [-] pick: keep that commit
  \item [-] squash: combine commit with previous one
  \item [-] edit: gives the opportunitu to alter the staged snapshot before committing it. \verb|git rebase --amend| to add changes to commit and \verb|git rebase --continue| to continue rebase
\end{itemize}
If lost in the middle of a rebase and afraid to continue use \verb|git rebase --abort| to abandon it and start over from scratch.
$ $\\

\section{Rewriting history}

Split commits:
\begin{verbatim}
  git rebase -i <base>
\end{verbatim}
Then use the \verb|edit| command on the commit you want to split.\\
The repository history will be set just after that commit.\\
Instead of \verb|git rebase --amend| that would allow to modify the commited snapshot, the commit is completely removed with: \\ \verb|git reset --mixed HEAD|\textasciitilde \verb|1|
\begin{itemize}
  \item [-] The \verb|HEAD|\textasciitilde \verb|1| parameter tells it to reset to the commit that occurs immediately before the current HEAD
  \item [-] The \verb|-- mixed| flag preserves the working directory
\end{itemize}
It's then possible to make as many commits as possible and finish with \verb|git rebase --continue|\\

View every change made in the repository:
\begin{verbatim}
  git reflog
\end{verbatim}
Rq. It's possible with it to find dangling commits that would otherwise be lost from the project history.

\section{Remotes}

\end{document}
